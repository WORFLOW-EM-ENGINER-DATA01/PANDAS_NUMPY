{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "```python\n",
    "import numpy as np \n",
    "\n",
    "DIM = 5\n",
    "MAX_NUM = 50\n",
    "\n",
    "dataset = np.random.randint(1, MAX_NUM, size=(DIM, DIM) )\n",
    "\n",
    "print(dataset)\n",
    "\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[ True  True False  True False]\n",
      "m [22 33 44]\n",
      "{33: 1, 44: 1, 22: 2}\n",
      "[[ 9 12  3 37 32]\n",
      " [23 18  3 20 35]]\n",
      "------deuxième masque-----\n",
      "[[ 9 12  3 37 32]\n",
      " [23 18  3 20 35]]\n"
     ]
    }
   ],
   "source": [
    "# 1. Générez une liste des multiples de 11 inférieurs à MAX_NUM\n",
    "# Une solution simple et immédiate est d'utiliser la fonction np.arange de Numpy\n",
    "y = np.arange(11, 50, 11)\n",
    "\n",
    "# Sinon vous pouvez toujours faire un Algorithme en Python & Numpy\n",
    "# pour générer la solution mais c'est un peu plus long\n",
    "\"\"\"\n",
    "y = []\n",
    "num = 11\n",
    "count = 1\n",
    "while num < MAX_NUM:    \n",
    "    y.append(num)\n",
    "    count += 1\n",
    "    num = 11 * count\n",
    "print(y)\n",
    "\n",
    "y = np.array(y)\n",
    "\n",
    "\"\"\"\n",
    "\n",
    "# print( np.isin(dataset, y) )\n",
    "# sur les lignes\n",
    "mask = np.any( np.isin(dataset, y), axis=1)\n",
    "print(mask)\n",
    "\n",
    "# Une autre manière de faire plus rapide (...) aurait été de chercher les multiples de 11 par ligne comme suit\n",
    "mask2 = np.any( dataset % 11 == 0, axis =1)\n",
    "\n",
    "# 2. En utilisant np.isin(dataset, multiple11 ) trouvez tous les nombres multiples de 11 dans le dataset. \n",
    "\n",
    "# Vous pouvez également compter le nombre de chaque multiple présent \n",
    "# dans ce tableau\n",
    "\n",
    "# unique récupére dans le dataset les multiples qu'une seule fois\n",
    "m = np.unique( dataset[ np.isin(dataset, y) ] )\n",
    "print('m', m)\n",
    "u, count = np.unique( dataset[ np.isin(dataset, y) ], return_counts=True)\n",
    "\n",
    "print( dict( zip(u, count)) )\n",
    "\n",
    "# print(dataset)\n",
    "\n",
    "# 3. Supprimez maintenant toutes les lignes du tableau ayant au moins un 0\n",
    "\n",
    "# En utilisant le mask\n",
    "# Il suffit de faire la négation du mask\n",
    "print(dataset[~mask])\n",
    "\n",
    "print('------deuxième masque-----')\n",
    "# Ceci marchait également avec le masque mask2\n",
    "print(dataset[~mask2])\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "## Supprimer des lignes avec des données manquantes\n",
    "\n",
    "Souvent dans les datasets des données manquent. Elles ont le type NaN dans Numpy. Pour qu'un tableau Numpy puisse contenir ce type de données manquantes il doit avoir le type float64 :\n",
    "\n",
    "```python\n",
    "\n",
    "# Sans définir le type du tableau celui-ci aura le type float64\n",
    "x = np.array([[1,2,3], [4,5,np.nan], [7,8,9]])\n",
    "\n",
    "print(x.dtype)\n",
    "# float64\n",
    "\n",
    "```\n",
    "\n",
    "La méthode np.isnan suivante permet de créer un masque sur les données manquent du tableau :\n",
    "\n",
    "```python\n",
    "np.isnan(x)\n",
    "\"\"\"\n",
    "[[False False False]\n",
    " [False False  True]\n",
    " [False False False]]\n",
    "\"\"\"\n",
    "```\n",
    "## Correction :\n",
    "\n",
    "```python\n",
    "\n",
    "x = np.array([[1,2,3], [4,5,np.nan], [7,8,9]])\n",
    "\n",
    "print(x)\n",
    "\n",
    "print(np.isnan(x))\n",
    "print(np.any(np.isnan(x), 1))\n",
    "print(x[ ~np.any(np.isnan(x), 1) ])\n",
    "\n",
    "\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[  1.   2.   3.]\n",
      " [  4.   5.  nan]\n",
      " [  7.   8.   9.]]\n",
      "[[False False False]\n",
      " [False False  True]\n",
      " [False False False]]\n",
      "[False  True False]\n",
      "[[ 1.  2.  3.]\n",
      " [ 7.  8.  9.]]\n",
      "[[ 1.  2.]\n",
      " [ 4.  5.]\n",
      " [ 7.  8.]]\n"
     ]
    }
   ],
   "source": [
    "x = np.array([[1,2,3], [4,5,np.nan], [7,8,9]])\n",
    "\n",
    "print(x)\n",
    "\n",
    "print(np.isnan(x))\n",
    "print(np.any(np.isnan(x), 1))\n",
    "print(x[ ~np.any(np.isnan(x), 1) ])\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.5.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
